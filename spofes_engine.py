# -*- coding: utf-8 -*-
"""スポフェス

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12ZbzS5QwU_vtViS1Jqxxs5E11WjC4YmK
"""

classes = [
    ("1A", 1, "赤"), ("1B", 1, "青"), ("1C", 1, "黄"),
    ("1D", 1, "赤"), ("1E", 1, "青"), ("1F", 1, "黄"),
    ("1G", 1, "赤"), ("1H", 1, "青"), ("1I", 1, "黄"),
    ("2A", 2, "赤"), ("2B", 2, "青"), ("2C", 2, "黄"),
    ("2D", 2, "赤"), ("2E", 2, "青"), ("2F", 2, "黄"),
    ("2G", 2, "赤"), ("2H", 2, "青"), ("2I", 2, "黄"),
    ("3A", 3, "赤"), ("3B", 3, "青"), ("3C", 3, "黄"),
    ("3D", 3, "赤"), ("3E", 3, "青"), ("3F", 3, "黄"),
    ("3G", 3, "赤"), ("3H", 3, "青"), ("3I", 3, "黄"),
]

events = {
  "リレー(男子)": {"participants": {"1A", "1B", "1C","2A","2B","2C","2D","3A","3B", "3C"}, "gender": "M", "min_teams": 3, "parallel": 2,"min_games": 3,"tournament_max_teams": 6},
  "リレー(女子)": {"participants": {"1A","1D", "1E", "1F","2D","2E","2F","3A","3D","3E", "3F"}, "gender": "F", "min_teams": 3, "parallel": 2},
  "ドッジ(女子)": {"participants": {"1G","1H", "1I", "2G","2H","2I","3G","3H","3I"}, "gender": "F", "min_teams": 3, "parallel": 2,"tournament_max_teams": 6},
  "綱引き(混合)": {"participants": {"1B","1H","2A","2E","3B","3I"}, "gender": "X", "min_teams": 3, "parallel": 2,"tournament_max_teams": 4},
}

MATCH_MIN = 5
CHANGE_MIN = 3

"""# このブロックはいじらないでください"""

from collections import defaultdict
import random
import itertools
import math
from collections import defaultdict
from collections import deque

"""## 時刻"""

def add_minutes(hhmm: str, minutes: int) -> str:
    h, m = map(int, hhmm.split(":"))
    total = h * 60 + m + minutes
    return f"{total // 60:02d}:{total % 60:02d}"

def add_times_to_timetable(raw_slots, start_time="09:00", match_min=10, change_min=3):
    t = start_time
    out = []
    for slot in raw_slots:
        # 1スロット内の試合に同じ開始・終了時刻を付ける
        slot_out = []
        start = t
        end = add_minutes(start, match_min)
        for g in slot:
            gg = dict(g)
            gg["start"] = start
            gg["end"] = end
            slot_out.append(gg)
        out.append(slot_out)
        t = add_minutes(end, change_min)
    return out

def print_timetable(timetable, title="タイムテーブル"):
    print("=" * 70)
    print(title)
    print("=" * 70)
    for si, slot in enumerate(timetable, 1):
        if not slot:
            continue
        start = slot[0].get("start", "??:??")
        end = slot[0].get("end", "??:??")
        print(f"\n[時程 {si}] {start}-{end}")
        for g in slot:
            ev = g.get("event", "")
            name = g.get("name", "")
            a, b = g.get("display_teams", g.get("teams", (None, None)))
            ref = g.get("referee", "未定")
            print(f"  - {ev} | {name}: {a} vs {b} | 審判: {ref}")

"""## 男女/混合：リソース化（試合の重複判定用）"""

def resources_of_team(team, gender):
    """team: '1A' など。gender: 'M'/'F'/'X'"""
    if team is None:
        return set()
    if gender == "M":
        return {f"{team}_M"}
    if gender == "F":
        return {f"{team}_F"}
    # X(混合) は両方
    return {f"{team}_M", f"{team}_F"}

def game_resources_only(game):
    """その試合が同時刻に占有するリソース集合"""
    # 敗者戦（順位ラベル）は別種目と衝突判定したくないのでリソース無し扱い
    if game.get("phase") == "consolation":
        return set()
    gender = game.get("gender", "X")
    used = set()
    for t in game.get("teams", (None, None)):
        if t is None:
            continue
        used |= resources_of_team(t, gender)
    return used

def game_teams_only(game):
    """ログ表示用（クラス名）"""
    a, b = game.get("teams", (None, None))
    return {t for t in (a, b) if t is not None}

"""## 予選"""

import string
import random

def split_into_leagues_by_min_teams(participants, min_teams, seed=0):
    """
    participants: list[str]
    min_teams: int
    戻り値: {"A":[...], "B":[...], ...}
    各リーグ人数は min_teams または min_teams+1
    """
    rng = random.Random(seed)
    parts = list(participants)
    rng.shuffle(parts)

    N = len(parts)
    k = min_teams

    if N < k:
        return {"A": parts}

    L = N // k          # リーグ数（商）
    r = N % k           # 余り → k+1 人リーグの数

    league_sizes = [k + 1] * r + [k] * (L - r)

    leagues = {}
    idx = 0
    for i, size in enumerate(league_sizes):
        name = string.ascii_uppercase[i]
        leagues[name] = parts[idx:idx + size]
        idx += size

    return leagues

def make_all_pairs(teams):
    pairs = []
    for i in range(len(teams)):
        for j in range(i + 1, len(teams)):
            pairs.append((teams[i], teams[j]))
    return pairs

def make_league_round_robin_games(event_name, event_info, leagues):
    """
    leagues: {"A":[...], "B":[...], ...}
    返り値: games(list[dict]) 予選試合のフラットなリスト
    """
    games = []
    gender = event_info.get("gender", "X")

    for L in sorted(leagues.keys()):
        teams = leagues[L]
        pairs = make_all_pairs(teams)
        for idx, (a, b) in enumerate(pairs, 1):
            games.append({
                "event": event_name,
                "gender": gender,
                "name": f"{L}-予選{idx}",   # ←「A-予選1」みたいになる
                "teams": (a, b),
                "display_teams": (f"{L}{a}", f"{L}{b}"),
                "league": L,
                "phase": "prelim",
            })
    return games

"""## 空き枠計算"""

def _minutes_between(t1: str, t2: str) -> int:
    """t2 - t1 を分で返す（t2が後なら正）"""
    h1, m1 = map(int, t1.split(":"))
    h2, m2 = map(int, t2.split(":"))
    return (h2 * 60 + m2) - (h1 * 60 + m1)

def _end_time_after_slots(start_time: str, n_slots: int, match_min: int, change_min: int) -> str:
    """n_slots 個の枠を消化したときの“次に始まる時刻”を返す"""
    t = start_time
    for _ in range(n_slots):
        t = add_minutes(t, match_min)   # 試合
        t = add_minutes(t, change_min)  # 移動
    return t

def _num_empty_slots_to_reach(start_time: str, target_time: str, match_min: int, change_min: int) -> int:
    """start_time から target_time まで、空き枠（試合+移動）を何枠入れると届くか"""
    slot_len = match_min + change_min
    diff = _minutes_between(start_time, target_time)
    if diff <= 0:
        return 0
    # 1枠の長さで切り上げ
    return (diff + slot_len - 1) // slot_len

# ==============================
#  Seed方式：本選チーム数を n 以下に制限
# ==============================

def build_advancers_limited_by_n(leagues: dict, max_teams: int = 8):
    """
    leagues: {"A":[...], "B":[...], ...}
    max_teams: 本選に進む最大チーム数（デフォ8）

    戻り値:
      advancers: 本選に進む順位ラベル（強い順想定）
      losers_by_rank: {rank: [順位ラベル,...]} 敗者戦用
    """
    league_names = sorted(leagues.keys())
    max_rank = max(len(ts) for ts in leagues.values())

    advancers = []
    losers_by_rank = defaultdict(list)

    # ラウンドロビン的に「1位→2位→3位…」で拾う
    for rank in range(1, max_rank + 1):
        for L in league_names:
            if len(leagues[L]) >= rank:
                label = f"{L}{rank}位"
                if len(advancers) < max_teams:
                    advancers.append(label)
                else:
                    losers_by_rank[rank].append(label)

    return advancers, losers_by_rank

"""## トーナメント"""

def make_seeded_pairs(advancers, bracket_size):
    """
    advancers: 強い順（例：A1位,B1位,C1位,A2位,...）を想定
    bracket_size: 2冪
    初戦：1番シード vs 最下位シード（1 vs last）方式
    """
    seeds = list(advancers) + [None] * max(0, bracket_size - len(advancers))

    pairs = []
    for i in range(bracket_size // 2):
        a = seeds[i]
        b = seeds[bracket_size - 1 - i]
        pairs.append((a, b))
    return pairs

def _next_pow2(n: int) -> int:
    p = 1
    while p < n:
        p *= 2
    return p

def round_name(n):
    # 8→準々決勝, 4→準決勝, 2→決勝
    if n == 2:
        return "決勝"
    if n == 4:
        return "準決勝"
    if n == 8:
        return "準々決勝"
    return f"{n}回戦"

def make_tournament_timetable_from_advancers(event_name, gender, advancers):
    """
    advancers（順位ラベル）から本選トーナメント時程（ラベル埋め）を生成する。
    - 初戦：シードでペアを作る
    - 2回戦以降：『◯◯ 勝ち』形式
    """
    n = len(advancers)
    if n < 2:
        return []

    bracket = _next_pow2(n)
    first_pairs = make_seeded_pairs(advancers, bracket)

    raw = []
    cur = bracket
    prev_match_names = None

    while cur >= 2:
        rname = round_name(cur)  # 例: 4→準決勝, 2→決勝
        m = cur // 2
        slot = []
        match_names = []

        for i in range(1, m + 1):
            mname = f"{rname}{i}" if m > 1 else f"{rname}"
            match_names.append(mname)

            if prev_match_names is None:
                a, b = first_pairs[i - 1]
            else:
                src1 = prev_match_names[2*(i-1)]
                src2 = prev_match_names[2*(i-1) + 1]
                a = f"{src1} 勝ち"
                b = f"{src2} 勝ち"

            slot.append({
                "event": event_name,
                "gender": gender,
                "name": mname,
                "teams": (a, b),
            })

        raw.append(slot)
        prev_match_names = match_names
        cur //= 2

    return raw

import re

def extract_league_from_label(label: str) -> str:
    """
    'A3位' → 'A'
    'AB10位' → 'AB'
    取れなければ label をそのまま返す
    """
    m = re.match(r'^([A-Z]+)', str(label))
    return m.group(1) if m else str(label)

def make_consolation_from_losers_by_rank(event_name, gender, losers_by_rank):
    """
    敗者戦：下位組だけを同順位同士で組む。
    - 可能な限り「同じリーグ同士」を避ける
    - 偶数：2つずつペア（異リーグ優先）
    - 奇数（余り1）：最後に3チーム総当たり（できれば全て異リーグ）
      例：X,Y,Z → XvsY, XvsZ, YvsZ
    """
    games = []
    idx = 1

    def league_of(label):
        return extract_league_from_label(label)

    def pick_partner(i_label, pool):
        """i_label と異リーグの相手を優先して1つ選ぶ。無ければ先頭。"""
        li = league_of(i_label)
        for j, cand in enumerate(pool):
            if league_of(cand) != li:
                return j
        return 0  # どうしても無理なら同リーグでも組む

    def pick_best_triple(pool):
        """
        pool（残り候補）から3つ選ぶ。
        リーグの重複が最小になる組（=異リーグが最大）を選ぶ。
        """
        best = None
        best_score = None  # (重複数, ランダム性なしの安定) -> 重複数が小さいほど良い

        # 全探索（poolが大きくても同順位の敗者は通常リーグ数程度なので軽い）
        n = len(pool)
        for a in range(n):
            for b in range(a + 1, n):
                for c in range(b + 1, n):
                    tri = [pool[a], pool[b], pool[c]]
                    leagues = [league_of(x) for x in tri]
                    dup = 3 - len(set(leagues))  # 0が理想
                    score = (dup, a + b + c)
                    if best_score is None or score < best_score:
                        best_score = score
                        best = tri
                        if dup == 0:
                            # これ以上良い（重複なし）はないので早期終了してもOKだが、
                            # 安定性のため一旦続行せず即returnしてよい
                            return best
        return best  # Noneは起きない（len>=3前提）

    for rank in sorted(losers_by_rank.keys()):
        pool = list(losers_by_rank[rank])
        if len(pool) < 2:
            continue

        # ---------- 奇数なら、最後に3チーム総当たり用の3つを確保 ----------
        triple = None
        if len(pool) % 2 == 1 and len(pool) >= 3:
            triple = pick_best_triple(pool)
            # triple を pool から取り除く
            triple_set = set(triple)
            pool = [x for x in pool if x not in triple_set]

        # ---------- 残り（偶数）を「同リーグ回避」しつつペアリング ----------
        # シンプルな貪欲：先頭を取り、異リーグの相手がいればそれ、無ければ妥協
        while len(pool) >= 2:
            a = pool.pop(0)
            j = pick_partner(a, pool)
            b = pool.pop(j)

            games.append({
                "event": event_name,
                "gender": gender,
                "name": f"敗者戦{idx}",
                "teams": (a, b),
                "phase": "consolation",
            })
            idx += 1

        if triple is not None:
            x, y, z = triple

            # (x vs y) の審判は z
            games.append({
                "event": event_name,
                "gender": gender,
                "name": f"敗者戦{idx}-総当たり1",
                "teams": (x, y),
                "referee_hint": z,
                "is_rr3": True,
                "rr3_teams": (x, y, z),
                "phase": "consolation",
            })
            idx += 1

            # (x vs z) の審判は y
            games.append({
                "event": event_name,
                "gender": gender,
                "name": f"敗者戦{idx}-総当たり2",
                "teams": (x, z),
                "referee_hint": y,
                "is_rr3": True,
                "rr3_teams": (x, y, z),
                "phase": "consolation",
            })
            idx += 1

            # (y vs z) の審判は x
            games.append({
                "event": event_name,
                "gender": gender,
                "name": f"敗者戦{idx}-総当たり3",
                "teams": (y, z),
                "referee_hint": x,
                "is_rr3": True,
                "rr3_teams": (x, y, z),
                "phase": "consolation",
            })
            idx += 1


    return games

"""## 敗者戦"""

import re

def count_games_per_team(all_event_results):
    """
    各チームの予選での試合数をカウント
    戻り値: {event_name: {team: game_count}}
    """
    game_count_by_event = {}

    for ev in all_event_results:
        game_count = defaultdict(int)
        event_name = ev["event"]

        # 予選での試合数（リーグサイズ - 1）
        for league_name, teams in ev["leagues"].items():
            games_per_team = len(teams) - 1
            for team in teams:
                game_count[team] += games_per_team

        game_count_by_event[event_name] = dict(game_count)

    return game_count_by_event

def verify_min_games(all_event_results, consolation_games_by_event, min_games=3):
    """
    各チームの試合数（予選+敗者戦+本選）を確認（順位ラベルベース）
    最低試合数に満たないチームを警告

    重要：
    - 順位ラベル（A1位、B2位など）ベースでカウント
    - 予選での試合数は、所属リーグのサイズから計算
    - 敗者戦・本選は実際のラベルでカウント

    戻り値: {event_name: {team_label: actual_games}}
    """
    game_count = defaultdict(lambda: defaultdict(int))

    # ========== ステップ1：予選での試合数を順位ラベルで記録 ==========
    # リーグ内総当たり：m位のチームは (m-1) 試合
    for ev in all_event_results:
        event_name = ev["event"]
        for league_name, teams in ev["leagues"].items():
            games_per_team = len(teams) - 1
            # 各位（1位、2位、3位...）に games_per_team 試合を加算
            for rank in range(1, len(teams) + 1):
                label = f"{league_name}{rank}位"
                game_count[event_name][label] += games_per_team

    # ========== ステップ2：敗者戦での試合数 ==========
    losers_set = set()  # 敗者戦に出るラベル

    for event_name, cons_games in consolation_games_by_event.items():
        for game in cons_games:
            for team in game.get("teams", (None, None)):
                if team:
                    game_count[event_name][team] += 1
                    losers_set.add(team)

    # ========== ステップ3：本選での試合数（本選に進むチームのみ） ==========
    for ev in all_event_results:
        event_name = ev["event"]
        tournament_size = ev.get("tournament_size", 0)

        if tournament_size >= 2:
            n = int(tournament_size or 0)
            p = 1
            while p < n:
                p *= 2

            # 本選のラウンド数を計算
            num_rounds = 0
            temp = p
            while temp >= 2:
                num_rounds += 1
                temp //= 2

            # 本選に進むシード
            seeds = build_seeds_from_leagues(ev["leagues"], p)

            # 本選に進むチーム（最大n個のシード）
            for i, seed in enumerate(seeds[:n]):
                if seed and seed not in losers_set:
                    # 本選に進み、敗者戦には出ないチーム
                    game_count[event_name][seed] += num_rounds

    # ========== ステップ4：警告と詳細表示 ==========
    warnings = []

    print("\n【試合数確認】")
    print("=" * 70)

    for event_name in sorted(game_count.keys()):
        print(f"\n{event_name}:")

        for label in sorted(game_count[event_name].keys()):
            count = game_count[event_name][label]
            status = "✅" if count >= min_games else "⚠️"

            # どの段階に参加しているか表示
            if label in losers_set:
                stage = "（予選+敗者戦）"
            else:
                stage = "（予選+本選）"

            print(f"  {status} {label}: {count} 試合{stage}")

            if count < min_games:
                warnings.append(
                    f"警告: {event_name} の {label} は {count} 試合（最低 {min_games} 試合必要）"
                )

    # 最終判定
    print("\n" + "=" * 70)
    if warnings:
        print("❌ 以下のチームが最低試合数を満たしていません:")
        for w in warnings:
            print(f"  {w}")
    else:
        print(f"✅ 全チームが最低 {min_games} 試合以上確保されました")

    return dict(game_count)

"""## スケジューリング"""

def make_event_schedule(event_name, event_info, classes, league_seed=0):
    """
    Seed方式（本選チーム数 n 制限）版
    """
    participants = list(event_info.get("participants", []))
    gender = event_info.get("gender", "X")
    min_teams = int(event_info.get("min_teams", 3))

    # ★リーグ分け
    leagues = split_into_leagues_by_min_teams(
        participants, min_teams=min_teams, seed=league_seed
    )

    team_to_league = {}
    for L, ts in leagues.items():
        for t in ts:
            team_to_league[t] = L

    # ★予選
    league_games = make_league_round_robin_games(event_name, event_info, leagues)

    # ★本選進出（最大 n チーム）
    max_teams = int(event_info.get("tournament_max_teams", 8))
    advancers, losers_by_rank = build_advancers_limited_by_n(
        leagues, max_teams=max_teams
    )

    # ★本選トーナメント
    tourn_raw = make_tournament_timetable_from_advancers(
        event_name, gender, advancers
    )

    # ★敗者戦（下位のみ）
    consolation_games = make_consolation_from_losers_by_rank(
        event_name, gender, losers_by_rank
    )

    return {
        "event": event_name,
        "gender": gender,
        "leagues": leagues,
        "team_to_league": team_to_league,
        "league_games": league_games,
        "tournament_slots": tourn_raw,
        "parallel": int(event_info.get("parallel", 2)),
        "consolation_games": consolation_games,
        "consolation_parallel": int(event_info.get("consolation_parallel", 1)),
        "advancers": advancers,
        "losers_by_rank": dict(losers_by_rank),
    }

def build_event_queues(all_event_results, seed=0):
    rng = random.Random(seed)
    league_q = {}
    tourn_q = {}

    for ev in all_event_results:
        name = ev["event"]
        gender = ev.get("gender", "X")

        L = []
        for g in ev.get("league_games", []):
            gg = dict(g)
            gg["event"] = name
            gg["gender"] = gg.get("gender", gender)
            L.append(gg)
        rng.shuffle(L)

        # 予選が終わった「次の時程」から、この種目だけ敗者戦を開始できるように
        # 予選キューの末尾に敗者戦を連結する（敗者戦はphase="consolation"でresource判定無し）
        C = []
        for g in ev.get("consolation_games", []):
            gg = dict(g)
            gg["event"] = name
            gg["gender"] = gg.get("gender", gender)
            C.append(gg)
        league_q[name] = L + C


        tourn_q[name] = ev.get("tournament_slots", [])

    return league_q, tourn_q

import random

def pick_k_games_from_queue(q, k, forbidden, lookahead, rng=None, topn=20, pair_trials=200):
    """
    q の先頭 lookahead 個から k個選び、forbidden と衝突しない組を探す。
    戻り値: (picked_indices, picked_games, used_resources_set) or None

    rng: random.Random を渡すと再現可能なランダムになる
    topn: k==1 のとき「先頭 topn 候補」からランダムに選ぶ（先頭優先しつつ揺らす）
    pair_trials: k==2 のときランダム試行するペア数（大きいほど強いが重い）
    """
    if rng is None:
        rng = random  # 後方互換（ただし再現性は弱い）

    limit = min(lookahead, len(q))
    candidates = []
    for i in range(limit):
        g = q[i]
        used = game_resources_only(g)
        if used & forbidden:
            continue
        candidates.append((i, g, used))

    if k <= 0:
        return ([], [], set())

    if len(candidates) < k:
        return None

    # ---- k == 1 ----
    if k == 1:
        # なるべくキュー先頭を使いたいので、先頭 topn の範囲に絞ってランダム
        candidates.sort(key=lambda x: x[0])  # index昇順
        pool = candidates[:max(1, min(topn, len(candidates)))]
        i, g, used = pool[rng.randrange(len(pool))]
        return [i], [g], set(used)

    # ---- k == 2 ----
    if k == 2:
        # 目的：max(i1,i2) を小さくしつつ、同点はランダムで揺らす
        candidates.sort(key=lambda x: x[0])

        # まず「先頭寄り」だけに絞る（早く消化したい + 探索空間を縮める）
        pool = candidates[:max(2, min(topn * 2, len(candidates)))]

        best_score = None
        best = None

        # 1) ランダムにペアを試す
        #    （全探索より軽く、でも揺らぎが出る）
        n = len(pool)
        for _ in range(pair_trials):
            a = rng.randrange(n)
            b = rng.randrange(n - 1)
            if b >= a:
                b += 1
            i1, g1, u1 = pool[a]
            i2, g2, u2 = pool[b]
            if u1 & u2:
                continue
            union = set(u1 | u2)
            score = (max(i1, i2), len(union))

            if best_score is None or score < best_score:
                best_score = score
                best = (sorted([i1, i2]), [g1, g2], union)
            elif score == best_score:
                # 同点はランダムに入れ替えて揺らす
                if rng.random() < 0.5:
                    best = (sorted([i1, i2]), [g1, g2], union)

        # 2) ランダム試行で見つからない場合だけ、保険で（軽めの）決定的探索
        if best is None:
            for a in range(len(pool)):
                i1, g1, u1 = pool[a]
                for b in range(a + 1, len(pool)):
                    i2, g2, u2 = pool[b]
                    if u1 & u2:
                        continue
                    union = set(u1 | u2)
                    score = (max(i1, i2), len(union))
                    if best_score is None or score < best_score:
                        best_score = score
                        best = (sorted([i1, i2]), [g1, g2], union)

        if best is None:
            return None

        idxs, games, union = best
        return idxs, games, union

    # ---- k > 2 ----
    # 候補をシャッフルしてバックトラックの道筋に揺らぎを出す
    rng.shuffle(candidates)

    chosen = []
    used_total = set()

    def bt(start, left):
        nonlocal used_total
        if left == 0:
            return True
        for ci in range(start, len(candidates)):
            i, g, used = candidates[ci]
            if used & used_total:
                continue
            chosen.append((i, g, used))
            prev = used_total
            used_total = used_total | used
            if bt(ci + 1, left - 1):
                return True
            used_total = prev
            chosen.pop()
        return False

    if not bt(0, k):
        return None

    idxs = [x[0] for x in chosen]
    games = [x[1] for x in chosen]
    union = set().union(*(x[2] for x in chosen))
    return idxs, games, union

def schedule_leagues_parallel_flexible_backtracking(
    league_q,
    per_event_parallel=2,
    per_event_parallel_consolation=None,
    lookahead=80,
    seed=0,
    # 残りが少なくなったら先読みを強める（終盤詰み対策）
    auto_bump_lookahead=True,
    bump_threshold=10,
    bump_lookahead=80,
):
    """
    予選（or 敗者戦）の同時並行スケジューリング。

    - 各時程で、各種目から k 試合（通常 parallel）を選ぶ
    - 同時刻に同じリソース（男女/混合の占有）が重ならないように選ぶ
    - バックトラックで組合せを探索
    - 残り1試合なら1試合でOK（k=min(parallel, 残り)）
    """
    rng = random.Random(seed)
    events = list(league_q.keys())
    raw = []
    slot_no = 0

    # pick_k_games_from_queue が rng 引数を受け取る/受け取らない両対応
    def _pick(q, k, forbidden, lookahead):
        try:
            return pick_k_games_from_queue(q, k, forbidden, lookahead, rng=rng)
        except TypeError:
            return pick_k_games_from_queue(q, k, forbidden, lookahead)

    while True:
        if all(len(league_q[e]) == 0 for e in events):
            break

        if auto_bump_lookahead:
            total_left = sum(len(league_q[e]) for e in events)
            if total_left < bump_threshold:
                lookahead = max(lookahead, bump_lookahead)

        slot_no += 1

        need = {}
        actives = []
        for e in events:
            r = len(league_q[e])
            if r <= 0:
                continue

            pe = per_event_parallel[e] if isinstance(per_event_parallel, dict) else per_event_parallel
            # 先頭が敗者戦なら consolation_parallel を使う
            if league_q[e] and league_q[e][0].get("phase") == "consolation":
                if per_event_parallel_consolation is None:
                    pe = 1
                else:
                    pe = per_event_parallel_consolation.get(e, 1)
            k = min(pe, r)

            need[e] = k
            actives.append(e)

        rng.shuffle(actives)

        chosen = {}
        used_global = set()  # resources

        def dfs(idx):
            nonlocal used_global
            if idx == len(actives):
                return True

            ev = actives[idx]
            k = need[ev]
            q = league_q[ev]

            pick = _pick(q, k, used_global, lookahead)
            if pick is None:
                return False

            tries = [pick]

            # k==1 の揺らぎ：候補を少し増やす
            if k == 1:
                limit = min(lookahead, len(q))
                idxs = list(range(limit))
                rng.shuffle(idxs)
                extra = 0
                for i in idxs:
                    g = q[i]
                    used = game_resources_only(g)
                    if used & used_global:
                        continue
                    tries.append(([i], [g], set(used)))
                    extra += 1
                    if extra >= 20:
                        break

            # k==2 の揺らぎ：先頭付近の回転も試す（軽め）
            if k == 2:
                limit = min(lookahead, len(q))
                extra = 0
                for start in range(min(20, limit)):
                    rotated = [q[(start + j) % limit] for j in range(limit)]
                    pick2 = _pick(rotated, k, used_global, lookahead=limit)
                    if pick2 is None:
                        continue
                    rot_idxs, rot_games, used = pick2
                    real_idxs = sorted([(start + ri) % limit for ri in rot_idxs])
                    tries.append((real_idxs, rot_games, used))
                    extra += 1
                    if extra >= 20:
                        break

            for real_idxs, games, used in tries:
                chosen[ev] = (real_idxs, games, used)
                prev_used = used_global
                used_global = used_global | used
                if dfs(idx + 1):
                    return True
                used_global = prev_used
                chosen.pop(ev, None)

            return False

        ok = dfs(0)
        if not ok:
            msg = [f"予選 flexible（バックトラック）: 時程{slot_no}で組めません。"]
            msg.append(f"  途中までの使用リソース: {sorted(used_global)}")
            for ev in actives:
                q = league_q[ev]
                msg.append(f"  {ev}（この時程は{need[ev]}試合必要）の先頭10試合:")
                for j in range(min(10, len(q))):
                    msg.append(f"    - {q[j]['name']}: {sorted(game_teams_only(q[j]))}")
            raise RuntimeError("\n".join(msg))

        slot_games = []
        for ev in actives:
            real_idxs, games, used = chosen[ev]
            for i in sorted(real_idxs, reverse=True):
                del league_q[ev][i]
            slot_games.extend(games)

        raw.append(slot_games)

    return raw

def schedule_consolations_parallel_strict(cons_q, cons_parallel_map, fill_with_empty=True):
    """
    敗者戦を「本選と同じ考え方」で横並びにする。

    - 各 event について、pe(=consolation_parallel) 個ずつに分割して stream を作る
    - 各時程で、全 event から 1つずつ stream を取り出して結合（横並び）
    - ある event が先に尽きたら、その event は空（=何も出さない）
    """
    events = list(cons_q.keys())

    streams = {}
    idx = {}
    for e in events:
        pe = int(cons_parallel_map.get(e, 1))
        g = cons_q[e]
        streams[e] = [g[i:i+pe] for i in range(0, len(g), pe)]
        idx[e] = 0

    out = []
    while True:
        if all(idx[e] >= len(streams[e]) for e in events):
            break

        slot = []
        for e in events:
            if idx[e] < len(streams[e]):
                slot.extend(streams[e][idx[e]])
                idx[e] += 1
            else:
                if fill_with_empty:
                    pass

        if slot:
            out.append(slot)

    return out

def schedule_tournaments_parallel_strict(tourn_q, per_event_parallel=2, fill_with_bye=True):
    """
    既に tourn_q[event] が [slot, slot, ...]（=ラウンドごとの時程）なので、
    ここでは event を横に並べていくだけの簡易版。
    """
    events = list(tourn_q.keys())
    # それぞれの本選スロット列
    streams = {e: tourn_q[e][:] for e in events}
    idx = {e: 0 for e in events}

    out = []
    while True:
        if all(idx[e] >= len(streams[e]) for e in events):
            break

        slot = []
        for e in events:
            if idx[e] < len(streams[e]):
                slot.extend(streams[e][idx[e]])
                idx[e] += 1
            else:
                if fill_with_bye:
                    # 種目が先に終わったら空にする（BYE試合を作る場合はここを拡張）
                    pass
        if slot:
            out.append(slot)

    return out

"""## 審判"""

def _build_future_last_prelim_gamesets_by_event(raw_slots):
    """
    raw_slots から event -> 「予選が行われた最後の時程」の試合チーム集合(list[set]) を取る
    """
    last_prelim_by_event = {}
    for slot in raw_slots:
        tmp = defaultdict(list)
        for g in slot:
            name = g.get("name", "")
            if "予選" not in name:
                continue
            ev = g.get("event", "")
            teams = set(t for t in g.get("teams", (None, None)) if t is not None)
            if teams:
                tmp[ev].append(teams)
        for ev, gamesets in tmp.items():
            last_prelim_by_event[ev] = gamesets
    return last_prelim_by_event

def assign_referees_prev_else_future_prelim_last_one_team_each(
    raw_slots,
    all_classes,
    seed=0
):
    rng = random.Random(seed)
    ref_count = defaultdict(int)

    future_prelim_last = _build_future_last_prelim_gamesets_by_event(raw_slots)
    prev_by_event = defaultdict(list)

    def pick_best(teamset, blocked):
        cand = [t for t in teamset if (t is not None) and (t not in blocked)]
        if not cand:
            return None
        return min(cand, key=lambda t: (ref_count[t], rng.random()))

    for slot in raw_slots:
        games_by_event = defaultdict(list)
        for g in slot:
            games_by_event[g.get("event", "")].append(g)

        for ev, games in games_by_event.items():


            # ========== ここから：referee_hint を絶対固定 ==========
            fixed_games = []
            normal_games = []

            for g in games:
                hint = g.get("referee_hint")
                if hint:
                    # rr3 等：その試合をしていないチームに固定
                    g["referee"] = hint
                    g["_ref_fixed"] = True  # 後段で絶対に上書きさせない印
                    ref_count[hint] += 1
                    fixed_games.append(g)
                else:
                    normal_games.append(g)

            # 以降の通常割当は「固定済み以外」だけに適用
            games = normal_games
            if not games:
                continue
            # ========== ここまで：referee_hint を絶対固定 ==========


            ref_gamesets = prev_by_event.get(ev) if prev_by_event.get(ev) else future_prelim_last.get(ev)

            # 参照元が2試合 & 今も2試合以上 → それぞれの試合から（審判兼務OK）
            if ref_gamesets and len(ref_gamesets) >= 2 and len(games) >= 2:
                s0, s1 = ref_gamesets[0], ref_gamesets[1]

                def try_assign(order):
                    chosen = [None] * len(games)
                    for gi, teamset in order:
                        g = games[gi]
                        a, b = g.get("teams", (None, None))
                        blocked = {a, b}

                        p = pick_best(teamset, blocked)
                        if p is None:
                            return None
                        chosen[gi] = p
                    return chosen

                attempt1 = try_assign([(0, s0), (1, s1)])
                attempt2 = try_assign([(0, s1), (1, s0)]) if attempt1 is None else None
                desired = attempt1 or attempt2

                if desired:
                    for i in range(min(2, len(games))):
                        referee = desired[i]
                        if referee is None:
                            break
                        games[i]["referee"] = referee
                        ref_count[referee] += 1

                    union_set = set().union(*ref_gamesets)
                    for i in range(2, len(games)):
                        a, b = games[i].get("teams", (None, None))
                        blocked = {a, b}
                        candidates = {t for t in union_set if t is not None} - blocked
                        if not candidates:
                            candidates = set(all_classes) - blocked
                        if not candidates:
                            candidates = set(all_classes)

                        referee = min(candidates, key=lambda t: (ref_count[t], rng.random()))
                        games[i]["referee"] = referee
                        ref_count[referee] += 1

                    continue

            # それ以外
            for g in games:
                a, b = g.get("teams", (None, None))
                blocked = {a, b}

                candidates = set()
                if ref_gamesets:
                    candidates = {t for t in set().union(*ref_gamesets) if t is not None} - blocked
                if not candidates:
                    candidates = set(all_classes) - blocked
                if not candidates:
                    candidates = set(all_classes)

                referee = min(candidates, key=lambda t: (ref_count[t], rng.random()))
                g["referee"] = referee
                ref_count[referee] += 1

        # 次時程用
        new_prev = defaultdict(list)
        for g in slot:
            ev = g.get("event", "")
            teams = set(t for t in g.get("teams", (None, None)) if t is not None)
            if teams:
                new_prev[ev].append(teams)
        prev_by_event = new_prev

    return raw_slots, dict(ref_count)

def apply_tournament_referee_role_labels_from_second_slot(raw_slots):
    """
    本選(=名前に'予選'が無い試合)の審判を
    - 本選の最初の時程：上書きしない（通常審判のまま）
    - 本選の2時程目以降：直前本選時程の各試合に対応させて '<試合名> 負け'
    """
    prev_tourn_names_by_event = defaultdict(list)

    for slot in raw_slots:
        tourn_games_by_event = defaultdict(list)
        for g in slot:
            name = g.get("name", "")

            # 予選は除外
            if "予選" in name:
                continue

            # BYEは除外
            if "BYE" in name:
                continue

            # ★敗者戦（総当たり含む）は除外（ここが重要）
            if "敗者戦" in name:
                continue

            ev = g.get("event", "")
            tourn_games_by_event[ev].append(g)


        # 上書き（2時程目以降）
        for ev, games in tourn_games_by_event.items():
            prev_names = prev_tourn_names_by_event.get(ev, [])
            if prev_names:
                for i, g in enumerate(games):
                    if i < len(prev_names):
                        g["referee"] = f"{prev_names[i]} 負け"
                    else:
                        g["referee"] = f"{prev_names[-1]} 負け"

        # 次用
        new_prev = defaultdict(list)
        for ev, games in tourn_games_by_event.items():
            for g in games:
                new_prev[ev].append(g.get("name", "本選"))
        prev_tourn_names_by_event = new_prev

    return raw_slots

"""## 出力"""

def build_full_parallel_timetable_simplified(
    all_event_results,
    classes,
    start_time="09:00",
    match_min=10,
    change_min=3,
    per_event_parallel=2,
    lookahead=20,
    seed=0,
    tournament_start_time="13:00",
    enforce_tournament_start=True,
    min_games=3,
):
    """
    シンプル版：
    - 予選だけをスケジューリング（リソース制約あり）
    - 敗者戦を追加（リソース制約なし、段階的）
    - 本選を追加
    - lookahead は固定値
    """
    league_q, tourn_q = build_event_queues(all_event_results, seed=seed)

    per_event_parallel_map = {ev["event"]: ev.get("parallel", 2) for ev in all_event_results}
    cons_parallel_map = {ev["event"]: ev.get("consolation_parallel", 1) for ev in all_event_results}

    # ========== ステップ1：予選だけをスケジューリング ==========
    prelim_raw = schedule_leagues_parallel_flexible_backtracking(
        league_q,
        per_event_parallel=per_event_parallel_map,
        per_event_parallel_consolation=cons_parallel_map,
        lookahead=lookahead,
        seed=seed,
        auto_bump_lookahead=False,
    )





    # ========== ステップ4：本選開始時刻の調整 ==========
    after_prelim_time = _end_time_after_slots(start_time, len(prelim_raw), match_min, change_min)

    if enforce_tournament_start:
        late = _minutes_between(tournament_start_time, after_prelim_time)

        if late > 0:
            raise RuntimeError(
                f"本選を {tournament_start_time} に一斉開始したいのに、"
                f"予選+敗者戦が {after_prelim_time} までかかって {late} 分オーバーしています。"
                f"（parallel増/試合時間短縮/本選開始時刻を遅らせる等が必要）"
            )

        empty_slots = _num_empty_slots_to_reach(after_prelim_time, tournament_start_time, match_min, change_min)
        for _ in range(empty_slots):
            prelim_raw.append([])

    # ========== ステップ5：本選を追加 ==========
    tourn_raw = schedule_tournaments_parallel_strict(
        tourn_q,
        per_event_parallel=per_event_parallel_map,
        fill_with_bye=True
    )

    # ========== ステップ6：統合 ==========
    raw = prelim_raw + tourn_raw

    # ========== ステップ7：審判割当 ==========
    all_classes = [c[0] for c in classes]
    raw, _ = assign_referees_prev_else_future_prelim_last_one_team_each(raw, all_classes, seed=seed)
    raw = apply_tournament_referee_role_labels_from_second_slot(raw)

    # ========== ステップ8：時刻付与 ==========
    return add_times_to_timetable(raw, start_time, match_min, change_min)

def try_build_parallel_timetable_with_retries_v2(
    events,
    classes,
    start_time="09:00",
    match_min=10,
    change_min=3,
    lookahead=20,
    league_attempts=30,
    seed=0
):
    """
    シンプル版リトライロジック：
    - league_seed だけで何度も試す
    - lookahead は一定（増やさない）
    - schedule_attempts は不要

    戻り値: (timetable, info_dict)
    """
    rng = random.Random(seed)
    last_error = None
    prev_leagues = {}  # 同じリーグ分けの重複検出用

    for la in range(league_attempts):
        league_seed = seed + la * 10007 + rng.randint(0, 9999)

        # ========== リーグ分けを作成 ==========
        all_event_results = []
        for event_name, event_info in events.items():
            all_event_results.append(
                make_event_schedule(event_name, event_info, classes, league_seed=league_seed)
            )

        # ========== リーグ分けが前回と同じかチェック ==========
        current_leagues = {ev["event"]: ev["leagues"] for ev in all_event_results}

        if current_leagues == prev_leagues:
            # 同じリーグ分けになった→スキップして次を試す
            continue

        prev_leagues = current_leagues

        # ========== スケジューリングに挑戦（lookahead固定） ==========
        schedule_seed = league_seed + 97

        try:
            tt = build_full_parallel_timetable_simplified(
                all_event_results,
                classes,
                start_time=start_time,
                match_min=match_min,
                change_min=change_min,
                lookahead=lookahead,
                seed=schedule_seed,
                tournament_start_time="13:00",
                enforce_tournament_start=True,
                min_games=3,
            )

            return tt, {
                "success": True,
                "league_attempt": la,
                "league_seed": league_seed,
                "schedule_seed": schedule_seed,
                "lookahead": lookahead,
            }

        except RuntimeError as e:
            last_error = str(e)
            # lookahead を増やさず、単に次の league_seed を試す
            continue

    return None, {
        "success": False,
        "league_attempts": league_attempts,
        "last_error": last_error,
    }

"""# 実行"""

def debug_consolation_games_v2(events, classes, league_seed=42):
    """
    改善版：同じ順位同士で対戦する敗者戦の確認
    """
    print("\n【敗者戦の確認（同じ順位同士）】")
    print("=" * 70)

    for event_name, event_info in events.items():
        print(f"\n{event_name}:")

        ev = make_event_schedule(event_name, event_info, classes, league_seed=league_seed)

        print(f"  リーグ分け:")
        for L, teams in sorted(ev["leagues"].items()):
            print(f"    {L}: {teams}")

        print(f"  本選サイズ: {ev.get('tournament_size', 'N/A')}")

        cons_games = ev["consolation_games"]
        print(f"  敗者戦試合数: {len(cons_games)}")

        if cons_games:
            print(f"  敗者戦内容:")
            for game in cons_games:
                a, b = game["teams"]
                print(f"    - {game['name']}: {a} vs {b}")
        else:
            print(f"  敗者戦なし（全チームが最低試合数を満たす）")

        # 試合数の統計
        print(f"  試合数統計:")
        # リーグごとのサイズを確認
        for L, teams in sorted(ev["leagues"].items()):
            m = len(teams)
            prelim_games = m - 1
            print(f"    {L}: {m}チーム × 予選{prelim_games}試合 = {m * prelim_games}試合")

# デバッグ実行
debug_consolation_games_v2(events, classes, league_seed=42)

# その後、通常実行
final_timetable, info = try_build_parallel_timetable_with_retries_v2(
    events, classes,
    start_time="09:00",
    match_min=5,
    change_min=3,
    lookahead=20,
    league_attempts=30,
    seed=42
)

if info["success"]:
    print("✅ 成功！")
    print_timetable(final_timetable, title="【同時並行スケジュール】")
else:
    print("❌ 失敗")
    print(info["last_error"])

import csv

def export_leagues_and_timetable_csv(events, classes, final_timetable, info,
                                    leagues_csv="leagues.csv",
                                    timetable_csv="timetable.csv"):
    """
    - leagues.csv: event, league, team
    - timetable.csv: slot_no, start, end, event, name, team_a, team_b, referee, phase, gender
    """
    if not info.get("success"):
        raise RuntimeError("スケジュール生成が成功していないため、CSVを書き出せません。")

    # --------- リーグ分けを復元（成功した league_seed を使う）---------
    league_seed = info.get("league_seed", 0)
    all_event_results = [
        make_event_schedule(event_name, event_info, classes, league_seed=league_seed)
        for event_name, event_info in events.items()
    ]

    # ===== leagues.csv =====
    # Excelで文字化けしにくいように utf-8-sig（BOM付き）
    with open(leagues_csv, "w", newline="", encoding="utf-8-sig") as f:
        w = csv.writer(f)
        w.writerow(["event", "league", "team"])
        for ev in sorted(all_event_results, key=lambda x: x["event"]):
            ev_name = ev["event"]
            for L in sorted(ev["leagues"].keys()):
                for team in ev["leagues"][L]:
                    w.writerow([ev_name, L, team])

    # ===== timetable.csv =====
    with open(timetable_csv, "w", newline="", encoding="utf-8-sig") as f:
        w = csv.writer(f)
        w.writerow(["slot_no", "start", "end", "event", "name", "team_a", "team_b", "referee", "phase", "gender"])

        for slot_no, slot in enumerate(final_timetable, start=1):
            if not slot:
                # 空き枠も残したいならここで1行出す（不要ならcontinue）
                # w.writerow([slot_no, "", "", "", "", "", "", "", "", ""])
                continue

            for g in slot:
                start = g.get("start", "")
                end = g.get("end", "")
                ev = g.get("event", "")
                name = g.get("name", "")

                # 表示名があれば優先
                a, b = g.get("display_teams", g.get("teams", (None, None)))
                a = "" if a is None else str(a)
                b = "" if b is None else str(b)

                referee = g.get("referee", "")
                phase = g.get("phase", "")   # 予選/prelim, 敗者戦/consolation など
                gender = g.get("gender", "")

                w.writerow([slot_no, start, end, ev, name, a, b, referee, phase, gender])

    print(f"✅ 書き出しました: {leagues_csv}, {timetable_csv}")


# ---- 実行（成功時）----
if info.get("success"):
    export_leagues_and_timetable_csv(events, classes, final_timetable, info,
                                     leagues_csv="leagues.csv",
                                     timetable_csv="timetable.csv")
# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wumVLXvV_9rnWoWYdPxKjgCnPvYPWVTM
"""

# app.py
# streamlit run app.py

import io
import json
import pandas as pd
import streamlit as st
import string


# ã‚ãªãŸã®ã‚¨ãƒ³ã‚¸ãƒ³ã‚’importï¼ˆãƒ•ã‚¡ã‚¤ãƒ«åã«åˆã‚ã›ã¦å¤‰æ›´ï¼‰
import spofes_engine as eng
GRADE_OPTIONS = [1, 2, 3]
COLOR_OPTIONS = ["", "èµ¤", "é’", "é»„"]

def make_default_class_df(default_color=""):
    rows = []
    for letter in list(string.ascii_uppercase[:10]):  # 1å¹´ A-J
        rows.append({"å­¦å¹´": 1, "ã‚¯ãƒ©ã‚¹": letter, "è‰²": default_color})
    for letter in list(string.ascii_uppercase[:9]):   # 2å¹´ A-I
        rows.append({"å­¦å¹´": 2, "ã‚¯ãƒ©ã‚¹": letter, "è‰²": default_color})
    for letter in list(string.ascii_uppercase[:9]):   # 3å¹´ A-I
        rows.append({"å­¦å¹´": 3, "ã‚¯ãƒ©ã‚¹": letter, "è‰²": default_color})
    return pd.DataFrame(rows)

def build_classes_from_df(df):
    classes = []
    for _, r in df.iterrows():
        g = str(r["å­¦å¹´"]).strip()
        c = str(r["ã‚¯ãƒ©ã‚¹"]).strip().upper()
        color = str(r["è‰²"]).strip()
        if not g or not c or not color:
            continue
        classes.append([f"{g}{c}", int(g), color])
    return classes

def validate_colors(df: pd.DataFrame):
    """
    è‰²ãŒæœªå…¥åŠ›ã®ã‚¯ãƒ©ã‚¹ãŒã‚ã‚Œã°ã‚¨ãƒ©ãƒ¼ã«ã™ã‚‹
    """
    missing = df[df["è‰²"].astype(str).str.strip() == ""]

    if not missing.empty:
        names = [
            f'{int(r["å­¦å¹´"])}{r["ã‚¯ãƒ©ã‚¹"]}'
            for _, r in missing.iterrows()
        ]
        st.error(
            "âŒ è‰²ãŒæœªå…¥åŠ›ã®ã‚¯ãƒ©ã‚¹ãŒã‚ã‚Šã¾ã™ã€‚\n\n"
            + "ãƒ»" + "\nãƒ»".join(names)
        )
        st.stop()


st.set_page_config(page_title="ã‚¹ãƒãƒ•ã‚§ã‚¹è‡ªå‹•ç·¨æˆ", layout="wide")

st.title("ã‚¹ãƒãƒ•ã‚§ã‚¹è‡ªå‹•ç·¨æˆï¼ˆãƒªãƒ¼ã‚°åˆ†ã‘ï¼‹æ™‚ç¨‹è¡¨ï¼‹CSVå‡ºåŠ›ï¼‰")

# ----------------------------
# å…¥åŠ›ï¼šJSONã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ or ãƒ†ãƒ³ãƒ—ãƒ¬
# ----------------------------
st.header("â‘  ã‚¯ãƒ©ã‚¹è¨­å®š")

if "class_df" not in st.session_state:
    st.session_state.class_df = make_default_class_df()

if st.button("ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«æˆ»ã™"):
    st.session_state.class_df = make_default_class_df()

edited = st.data_editor(
    st.session_state.class_df,
    num_rows="dynamic",
    use_container_width=True,
    column_config={
        "å­¦å¹´": st.column_config.SelectboxColumn("å­¦å¹´", options=GRADE_OPTIONS, required=True),
        "ã‚¯ãƒ©ã‚¹": st.column_config.TextColumn("ã‚¯ãƒ©ã‚¹", help="A, B, C ...", required=True),
        "è‰²": st.column_config.SelectboxColumn("è‰²", options=COLOR_OPTIONS, required=True),
    },
)

st.session_state.class_df = edited
classes_ui = build_classes_from_df(st.session_state.class_df)


DEFAULT_CONFIG = {
    "classes": [
        ["1A", 1, "èµ¤"], ["1B", 1, "é’"], ["1C", 1, "é»„"],
    ],
    "events": {
        "ãƒªãƒ¬ãƒ¼(ç”·å­)": {
            "participants": ["1A", "1B", "1C"],
            "gender": "M",
            "min_teams": 3,
            "parallel": 2,
            "tournament_max_teams": 8,
            "consolation_parallel": 1
        }
    },
    "params": {
        "start_time": "09:00",
        "match_min": 5,
        "change_min": 3,
        "lookahead": 20,
        "league_attempts": 30,
        "seed": 42,
        "tournament_start_time": "13:00",
        "enforce_tournament_start": True,
        "min_games": 3
    }
}

uploaded = st.sidebar.file_uploader("è¨­å®šJSONã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰", type=["json"])

if "config" not in st.session_state:
    st.session_state.config = DEFAULT_CONFIG

if uploaded is not None:
    try:
        st.session_state.config = json.load(uploaded)
        st.sidebar.success("JSONã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ")
    except Exception as e:
        st.sidebar.error(f"JSONã®èª­ã¿è¾¼ã¿ã«å¤±æ•—: {e}")

st.sidebar.subheader("è¨­å®šJSONï¼ˆç·¨é›†å¯ï¼‰")
config_text = st.sidebar.text_area(
    "config",
    value=json.dumps(st.session_state.config, ensure_ascii=False, indent=2),
    height=380
)

colA, colB = st.sidebar.columns(2)
with colA:
    if st.button("ã“ã®JSONã‚’åæ˜ "):
        try:
            st.session_state.config = json.loads(config_text)
            st.success("åæ˜ ã—ã¾ã—ãŸ")
        except Exception as e:
            st.error(f"JSONãŒä¸æ­£ã§ã™: {e}")

with colB:
    st.download_button(
        "ãƒ†ãƒ³ãƒ—ãƒ¬JSONã‚’ä¿å­˜",
        data=json.dumps(DEFAULT_CONFIG, ensure_ascii=False, indent=2).encode("utf-8"),
        file_name="config_template.json",
        mime="application/json"
    )

cfg = st.session_state.config
# UIã§ä½œã£ãŸã‚¯ãƒ©ã‚¹ã‚’ config ã«ä¸Šæ›¸ã
cfg["classes"] = classes_ui
st.session_state.config = cfg

# JSONãŒç„¡ã„ã¨ãã®ä¿é™ºï¼ˆå‰ã«ã†ã¾ãã„ã£ãŸè¨­å®šï¼‰
cfg.setdefault("per_event_parallel", 1)

# ----------------------------
# å…¥åŠ›ãƒã‚§ãƒƒã‚¯ï¼ˆè»½ã‚ï¼‰
# ----------------------------
def normalize_config(cfg: dict):
    classes = cfg.get("classes", [])
    events = cfg.get("events", {})
    params = cfg.get("params", {})

    # classes: list[list] -> list[tuple]
    classes_t = [tuple(x) for x in classes]

    events_n = {}
    all_class_ids = [c[0] for c in classes]

    for name, info in events.items():
        ii = dict(info)
        parts = ii.get("participants", [])

        # participants ãŒç©ºãªã‚‰å…¨ã‚¯ãƒ©ã‚¹å‚åŠ 
        if not parts:
            parts = all_class_ids

        ii["participants"] = set(parts)
        events_n[name] = ii

    return classes_t, events_n, params


try:
    classes, events, params = normalize_config(cfg)
except Exception as e:
    st.error(f"è¨­å®šã®æ•´å½¢ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}")
    st.stop()

# ----------------------------
# å®Ÿè¡Œãƒœã‚¿ãƒ³
# ----------------------------
st.subheader("å®Ÿè¡Œ")

run = st.button("ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ç”Ÿæˆ", type="primary")

if run:
    # ğŸ”´ è‰²æœªå…¥åŠ›ãƒã‚§ãƒƒã‚¯
    validate_colors(st.session_state.class_df)

    with st.spinner("ç”Ÿæˆä¸­..."):
        try:
            final_timetable, info = eng.try_build_parallel_timetable_with_retries_v2(
                events=events,
                classes=classes,
                start_time=params.get("start_time", "09:00"),
                match_min=int(params.get("match_min", 5)),
                change_min=int(params.get("change_min", 3)),
                lookahead=int(params.get("lookahead", 20)),
                league_attempts=int(params.get("league_attempts", 30)),
                seed=int(params.get("seed", 42)),
            )

            if not info.get("success"):
                st.error("ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ")
                st.code(info.get("last_error", "unknown error"))
                st.stop()

            st.success("ç”ŸæˆæˆåŠŸï¼")
            st.session_state.final_timetable = final_timetable
            st.session_state.info = info

        except Exception as e:
            st.error(f"ä¾‹å¤–ã§åœæ­¢ã—ã¾ã—ãŸ: {e}")
            st.stop()

# ----------------------------
# çµæœè¡¨ç¤º
# ----------------------------
if "final_timetable" in st.session_state and "info" in st.session_state:
    final_timetable = st.session_state.final_timetable
    info = st.session_state.info

    # ãƒªãƒ¼ã‚°åˆ†ã‘ã‚’å¾©å…ƒ
    league_seed = info.get("league_seed", params.get("seed", 42))
    all_event_results = [
        eng.make_event_schedule(event_name, event_info, classes, league_seed=league_seed)
        for event_name, event_info in events.items()
    ]

    st.subheader("ãƒªãƒ¼ã‚°åˆ†ã‘")

    league_rows = []
    for ev in sorted(all_event_results, key=lambda x: x["event"]):
        ev_name = ev["event"]
        for L in sorted(ev["leagues"].keys()):
            for team in ev["leagues"][L]:
                league_rows.append({"event": ev_name, "league": L, "team": team})

    df_leagues = pd.DataFrame(league_rows)
    st.dataframe(df_leagues, use_container_width=True, hide_index=True)

    st.subheader("æ™‚ç¨‹è¡¨")

    tt_rows = []
    for slot_no, slot in enumerate(final_timetable, start=1):
        if not slot:
            continue
        for g in slot:
            a, b = g.get("display_teams", g.get("teams", (None, None)))
            tt_rows.append({
                "slot_no": slot_no,
                "start": g.get("start", ""),
                "end": g.get("end", ""),
                "event": g.get("event", ""),
                "name": g.get("name", ""),
                "team_a": "" if a is None else str(a),
                "team_b": "" if b is None else str(b),
                "referee": g.get("referee", ""),
                "phase": g.get("phase", ""),
                "gender": g.get("gender", "")
            })

    df_tt = pd.DataFrame(tt_rows)
    st.dataframe(df_tt, use_container_width=True, hide_index=True)

    # ----------------------------
    # CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
    # ----------------------------
    st.subheader("CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰")

    def to_csv_bytes(df: pd.DataFrame) -> bytes:
        # Excelã§æ–‡å­—åŒ–ã‘ã—ã«ãã„utf-8-sig
        return df.to_csv(index=False, encoding="utf-8-sig").encode("utf-8-sig")

    col1, col2 = st.columns(2)
    with col1:
        st.download_button(
            "leagues.csv ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰",
            data=to_csv_bytes(df_leagues),
            file_name="leagues.csv",
            mime="text/csv"
        )

    with col2:
        st.download_button(
            "timetable.csv ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰",
            data=to_csv_bytes(df_tt),
            file_name="timetable.csv",
            mime="text/csv"
        )

    st.caption(f"æˆåŠŸæƒ…å ±: {info}")

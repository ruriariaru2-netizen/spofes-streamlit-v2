# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wumVLXvV_9rnWoWYdPxKjgCnPvYPWVTM
"""

# app.py
# streamlit run app.py

import pandas as pd
import streamlit as st
import string


# ã‚ãªãŸã®ã‚¨ãƒ³ã‚¸ãƒ³ã‚’importï¼ˆãƒ•ã‚¡ã‚¤ãƒ«åã«åˆã‚ã›ã¦å¤‰æ›´ï¼‰
import spofes_engine as eng

def make_default_class_df():
    rows = []
    for letter in list(string.ascii_uppercase[:10]):  # 1å¹´ A-J
        rows.append({"å­¦å¹´": 1, "ã‚¯ãƒ©ã‚¹": letter, "èµ¤": False, "é’": False, "é»„": False})
    for letter in list(string.ascii_uppercase[:9]):   # 2å¹´ A-I
        rows.append({"å­¦å¹´": 2, "ã‚¯ãƒ©ã‚¹": letter, "èµ¤": False, "é’": False, "é»„": False})
    for letter in list(string.ascii_uppercase[:9]):   # 3å¹´ A-I
        rows.append({"å­¦å¹´": 3, "ã‚¯ãƒ©ã‚¹": letter, "èµ¤": False, "é’": False, "é»„": False})
    return pd.DataFrame(rows)


def build_classes_from_df(df):
    classes = []
    for _, r in df.iterrows():
        g = str(r["å­¦å¹´"]).strip()
        c = str(r["ã‚¯ãƒ©ã‚¹"]).strip().upper()

        colors = [col for col in ["èµ¤", "é’", "é»„"] if bool(r[col])]

        # è‰²ã¯ã¡ã‚‡ã†ã©1ã¤å¿…è¦
        if len(colors) != 1:
            continue

        color = colors[0]
        classes.append([f"{g}{c}", int(g), color])

    return classes


def validate_colors(df: pd.DataFrame):
    bad = []
    for _, r in df.iterrows():
        count = sum(bool(r[col]) for col in ["èµ¤", "é’", "é»„"])
        if count != 1:
            bad.append(f'{int(r["å­¦å¹´"])}{r["ã‚¯ãƒ©ã‚¹"]}')

    if bad:
        st.error(
            "âŒ è‰²ã¯ã€Œèµ¤ãƒ»é’ãƒ»é»„ã€ã®ã†ã¡1ã¤ã ã‘é¸ã‚“ã§ãã ã•ã„ã€‚\n\n"
            + "ãƒ»" + "\nãƒ»".join(bad)
        )
        st.stop()

def enforce_single_color(df: pd.DataFrame) -> pd.DataFrame:
    df = df.copy()
    for i, r in df.iterrows():
        flags = {c: bool(r[c]) for c in ["èµ¤", "é’", "é»„"]}
        on = [c for c, v in flags.items() if v]

        if len(on) <= 1:
            continue

        # è¤‡æ•°ONãªã‚‰ã€Œæœ€å¾Œã«ONã«ãªã£ãŸã£ã½ã„ã‚‚ã®ã€ã‚’æ¨æ¸¬ã§ããªã„ã®ã§
        # ã“ã“ã§ã¯å®‰å…¨ã«ã€Œèµ¤ã ã‘æ®‹ã™ã€ãªã©å›ºå®šã«ã™ã‚‹ã®ã‚‚æ‰‹ã€‚
        # ãŸã ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ„å›³ã—ãŸè‰²ã‚’å°Šé‡ã—ãŸã„ãªã‚‰ã€ã“ã“ã¯ãƒ«ãƒ¼ãƒ«ã‚’æ±ºã‚ã‚ˆã†ã€‚
        keep = on[-1]  # ã¨ã‚Šã‚ãˆãšæœ€å¾Œã®Trueã‚’æ®‹ã™ï¼ˆé †åºã¯èµ¤â†’é’â†’é»„ï¼‰
        for c in ["èµ¤", "é’", "é»„"]:
            df.at[i, c] = (c == keep)

    return df


DEFAULT_CONFIG = {
    "classes": [
        ["1A", 1, "èµ¤"], ["1B", 1, "é’"], ["1C", 1, "é»„"],
    ],
    "events": {
        "ãƒªãƒ¬ãƒ¼(ç”·å­)": {
            "participants": ["1A", "1B", "1C"],
            "gender": "M",
            "min_teams": 3,
            "parallel": 2,
            "tournament_max_teams": 8,
            "consolation_parallel": 1
        }
    },
    "params": {
        "start_time": "09:00",
        "match_min": 5,
        "change_min": 3,
        "lookahead": 20,
        "league_attempts": 30,
        "seed": 42,
        "tournament_start_time": "13:00",
        "enforce_tournament_start": True,
        "min_games": 3
    }
}

st.set_page_config(page_title="ã‚¹ãƒãƒ•ã‚§ã‚¹è‡ªå‹•ç·¨æˆ", layout="wide")


st.title("ã‚¹ãƒãƒ•ã‚§ã‚¹è‡ªå‹•ç·¨æˆï¼ˆãƒªãƒ¼ã‚°åˆ†ã‘ï¼‹æ™‚ç¨‹è¡¨ï¼‹CSVå‡ºåŠ›ï¼‰")

# ----------------------------
# å…¥åŠ›ï¼šJSONã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ or ãƒ†ãƒ³ãƒ—ãƒ¬
# ----------------------------
st.header("â‘  ã‚¯ãƒ©ã‚¹è¨­å®š")

if "class_df" not in st.session_state:
    st.session_state.class_df = make_default_class_df()

if st.button("ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«æˆ»ã™"):
    st.session_state.class_df = make_default_class_df()

edited = st.data_editor(
    st.session_state.class_df,
    num_rows="dynamic",
    use_container_width=True,
    column_config={
        "å­¦å¹´": st.column_config.SelectboxColumn("å­¦å¹´", options=[1, 2, 3], required=True),
        "ã‚¯ãƒ©ã‚¹": st.column_config.TextColumn("ã‚¯ãƒ©ã‚¹", required=True),
        "èµ¤": st.column_config.CheckboxColumn("èµ¤"),
        "é’": st.column_config.CheckboxColumn("é’"),
        "é»„": st.column_config.CheckboxColumn("é»„"),
    },
    key="class_editor",
)

st.session_state.class_df = enforce_single_color(edited)



st.session_state.class_df = enforce_single_color(edited)


# ----------------------------
# å…¥åŠ›ãƒã‚§ãƒƒã‚¯ï¼ˆè»½ã‚ï¼‰
# ----------------------------
def normalize_config(cfg: dict):
    classes = cfg.get("classes", [])
    events = cfg.get("events", {})
    params = cfg.get("params", {})

    # classes: list[list] -> list[tuple]
    classes_t = [tuple(x) for x in classes]

    events_n = {}
    all_class_ids = [c[0] for c in classes]

    for name, info in events.items():
        ii = dict(info)
        parts = ii.get("participants", [])

        # participants ãŒç©ºãªã‚‰å…¨ã‚¯ãƒ©ã‚¹å‚åŠ 
        if not parts:
            parts = all_class_ids

        ii["participants"] = set(parts)
        events_n[name] = ii

    return classes_t, events_n, params

# ----------------------------
# å®Ÿè¡Œãƒœã‚¿ãƒ³
# ----------------------------
st.subheader("å®Ÿè¡Œ")

run = st.button("ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ç”Ÿæˆ", type="primary")

if run:
    # ğŸ”´ è‰²æœªå…¥åŠ›ãƒã‚§ãƒƒã‚¯
    validate_colors(st.session_state.class_df)

    # UIã‹ã‚‰ classes ã‚’ç¢ºå®š
    classes = build_classes_from_df(st.session_state.class_df)

    # å†…éƒ¨ config ã‚’ã“ã“ã§çµ„ã¿ç«‹ã¦
    cfg = {
        **DEFAULT_CONFIG,          # events / params ã¯æ—¢å®šå€¤
        "classes": classes,
        "per_event_parallel": 1,
    }

    classes, events, params = normalize_config(cfg)

    with st.spinner("ç”Ÿæˆä¸­..."):
        try:
            final_timetable, info = eng.try_build_parallel_timetable_with_retries_v2(
                events=events,
                classes=classes,
                start_time=params.get("start_time", "09:00"),
                match_min=int(params.get("match_min", 5)),
                change_min=int(params.get("change_min", 3)),
                lookahead=int(params.get("lookahead", 20)),
                league_attempts=int(params.get("league_attempts", 30)),
                seed=int(params.get("seed", 42)),
            )

            if not info.get("success"):
                st.error("ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ")
                st.code(info.get("last_error", "unknown error"))
                st.stop()

            st.success("ç”ŸæˆæˆåŠŸï¼")
            st.session_state.final_timetable = final_timetable
            st.session_state.info = info
            st.session_state.classes = classes
            st.session_state.events = events
            st.session_state.params = params


        except Exception as e:
            st.error(f"ä¾‹å¤–ã§åœæ­¢ã—ã¾ã—ãŸ: {e}")
            st.stop()


# ----------------------------
# çµæœè¡¨ç¤º
# ----------------------------
if "final_timetable" in st.session_state and "info" in st.session_state:
    final_timetable = st.session_state.final_timetable
    info = st.session_state.info
    classes = st.session_state.classes
    events  = st.session_state.events
    params  = st.session_state.params

    # ãƒªãƒ¼ã‚°åˆ†ã‘ã‚’å¾©å…ƒ
    league_seed = info.get("league_seed", params.get("seed", 42))
    all_event_results = [
        eng.make_event_schedule(event_name, event_info, classes, league_seed=league_seed)
        for event_name, event_info in events.items()
    ]

    st.subheader("ãƒªãƒ¼ã‚°åˆ†ã‘")

    league_rows = []
    for ev in sorted(all_event_results, key=lambda x: x["event"]):
        ev_name = ev["event"]
        for L in sorted(ev["leagues"].keys()):
            for team in ev["leagues"][L]:
                league_rows.append({"event": ev_name, "league": L, "team": team})

    df_leagues = pd.DataFrame(league_rows)
    st.dataframe(df_leagues, use_container_width=True, hide_index=True)

    st.subheader("æ™‚ç¨‹è¡¨")

    tt_rows = []
    for slot_no, slot in enumerate(final_timetable, start=1):
        if not slot:
            continue
        for g in slot:
            a, b = g.get("display_teams", g.get("teams", (None, None)))
            tt_rows.append({
                "slot_no": slot_no,
                "start": g.get("start", ""),
                "end": g.get("end", ""),
                "event": g.get("event", ""),
                "name": g.get("name", ""),
                "team_a": "" if a is None else str(a),
                "team_b": "" if b is None else str(b),
                "referee": g.get("referee", ""),
                "phase": g.get("phase", ""),
                "gender": g.get("gender", "")
            })

    df_tt = pd.DataFrame(tt_rows)
    st.dataframe(df_tt, use_container_width=True, hide_index=True)

    # ----------------------------
    # CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
    # ----------------------------
    st.subheader("CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰")

    def to_csv_bytes(df: pd.DataFrame) -> bytes:
        # Excelã§æ–‡å­—åŒ–ã‘ã—ã«ãã„utf-8-sig
        return df.to_csv(index=False, encoding="utf-8-sig").encode("utf-8-sig")

    col1, col2 = st.columns(2)
    with col1:
        st.download_button(
            "leagues.csv ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰",
            data=to_csv_bytes(df_leagues),
            file_name="leagues.csv",
            mime="text/csv"
        )

    with col2:
        st.download_button(
            "timetable.csv ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰",
            data=to_csv_bytes(df_tt),
            file_name="timetable.csv",
            mime="text/csv"
        )

    st.caption(f"æˆåŠŸæƒ…å ±: {info}")
